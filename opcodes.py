# list of all opcodes
# opcodes[name] has a list of [value (index), no. of items removed from stack, no. of items added to stack]

opcodes = {
  "unreachable": [0x00, 0, 0, "trap immediately"],
  "nop": [0x01, 0, 0, "no operation"],
  "block": [0x02, 0, 0, "begin a sequence of expressions"],
  "loop": [0x03, 0, 0, "begin a block which can also form control flow loops"],
  "if": [0x04, 1, 0, "begin if expression"],
  "else": [0x05, 0, 0,"begin else expression of if"],
  "end": [0x0b, 0, 0,"end a block, loop, or if"],
  "br": [0x0c, 0, 0,"break that targets an outer nested block"],
  "br_if": [0x0d, 1, 0,"conditional break that targets an outer nested block"],
  "br_table": [0x0e, 1, 0,"branch table control flow construct"],
  "return": [0x0f, 1, 0,"return zero or one value from this function"],
  "call": [0x10, 0, 0,"call a function by its index"], 
  "call_indirect": [0x11, 1, 0, "call a function indirect with an expected signature"],

  "drop": [0x1a, 1, 0, "ignore value"],
  "select": [0x1b, 3, 1, "select one of two values based on condition"],

  "local.get": [0x20, 0, 1, "read a local variable or parameter"],
  "local.set": [0x21, 1, 0, "write a local variable or parameter"],
  "local.tee": [0x22, 1, 1, "write a local variable or parameter and read the same value"],
  "global.get": [0x23, 0, 1, "read a global variable"],
  "global.set": [0x24, 1, 0, "write a global variable"],

  "i32.load": [0x28, 1, 1, "load from memory"],
  "i64.load": [0x29, 1, 1, "load from memory"],
  "f32.load": [0x2a, 1, 1, "load from memory"],
  "f64.load": [0x2b, 1, 1,"load from memory"],
  "i32.load8_s": [0x2c, 1, 1, "load from memory"],
  "i32.load8_u": [0x2d, 1, 1, "load from memory"],
  "i32.load16_s": [0x2e, 1, 1, "load from memory"],
  "i32.load16_u": [0x2f, 1, 1, "load from memory"],
  "i64.load8_s": [0x30, 1, 1, "load from memory"],
  "i64.load8_u": [0x31, 1, 1, "load from memory"],
  "i64.load16_s": [0x32, 1, 1, "load from memory"],
  "i64.load16_u": [0x33, 1, 1, "load from memory"],
  "i64.load32_s": [0x34, 1, 1, "load from memory"],
  "i64.load32_u": [0x35, 1, 1, "load from memory"],
  "i32.store": [0x36, 2, 0, "store to memory"],
  "i64.store": [0x37, 2, 0,"store to memory"],
  "f32.store": [0x38, 2, 0, "store to memory"],
  "f64.store": [0x39, 2, 0, "store to memory"],
  "i32.store8": [0x3a, 2, 0, "store to memory"],
  "i32.store16": [0x3b, 2, 0, "store to memory"],
  "i64.store8": [0x3c, 2, 0, "store to memory"],
  "i64.store16": [0x3d, 2, 0, "store to memory"],
  "i64.store32": [0x3e, 2, 0,"store to memory"],
  "memory.size": [0x3f, 0, 1, "query the size of memory"],
  "memory.grow": [0x40, 0, 0, "grow the size of memory"],

  "i32.const": [0x41, 0, 1, "a constant value interpreted as i32"],
  "i64.const": [0x42, 0, 1, "a constant value interpreted as i64"],
  "f32.const": [0x43, 0, 1, "a constant value interpreted as f32"],
  "f64.const": [0x44, 0, 1, "a constant value interpreted as f64"],

  "i32.eqz": [0x45, 1, 1, "compare equal to zero (return 1 if operand is zero, 0 otherwise)"],
  "i32.eq": [0x46, 2, 1, "sign-agnostic compare equal"],
  "i32.ne": [0x47, 2, 1, "sign-agnostic compare unequal"],
  "i32.lt_s": [0x48, 2, 1, "signed less than"],
  "i32.lt_u": [0x49, 2, 1, "unsigned less than"],
  "i32.gt_s": [0x4a, 2, 1, "signed greater than"],
  "i32.gt_u": [0x4b, 2, 1, "unsigned greater than"],
  "i32.le_s": [0x4c, 2, 1, "signed less than or equal"],
  "i32.le_u": [0x4d, 2, 1, "unsigned less than or equal"],
  "i32.ge_s": [0x4e, 2, 1, "signed greater than or equal"],
  "i32.ge_u": [0x4f, 2, 1, "unsigned greater than or equal"],

  "i64.eqz": [0x50, 1, 1, "compare equal to zero (return 1 if operand is zero, 0 otherwise)"],
  "i64.eq": [0x51, 2, 1, "sign-agnostic compare equal"],
  "i64.ne": [0x52, 2, 1, "sign-agnostic compare unequal"],
  "i64.lt_s": [0x53, 2, 1, "signed less than"],
  "i64.lt_u": [0x54, 2, 1, "unsigned less than"],
  "i64.gt_s": [0x55, 2, 1, "signed greater than"],
  "i64.gt_u": [0x56, 2, 1, "unsigned greater than"],
  "i64.le_s": [0x57, 2, 1, "signed less than or equal"],
  "i64.le_u": [0x58, 2, 1, "unsigned less than or equal"],
  "i64.ge_s": [0x59, 2, 1, "signed greater than or equal"],
  "i64.ge_u": [0x5a, 2, 1, "unsigned greater than or equal"],

  "f32.eq": [0x5b, 2, 1, "compare ordered and equal"],
  "f32.ne": [0x5c, 2, 1, "compare unordered or unequal"],
  "f32.lt": [0x5d, 2, 1, "compare ordered and less than"],
  "f32.gt": [0x5e, 2, 1, "compare ordered and less than or equal"],
  "f32.le": [0x5f, 2, 1, "compare ordered and greater than"],
  "f32.ge": [0x60, 2, 1, "compare ordered and greater than or equal"],

  "f64.eq": [0x61, 2, 1, "compare ordered and equal"],
  "f64.ne": [0x62, 2, 1, "compare unordered or unequal"],
  "f64.lt": [0x63, 2, 1, "compare ordered and less than"],
  "f64.gt": [0x64, 2, 1, "compare ordered and less than or equal"],
  "f64.le": [0x65, 2, 1, "compare ordered and greater than"],
  "f64.ge": [0x66, 2, 1, "compare ordered and greater than or equal"],

  "i32.clz": [0x67, 1, 1, "sign-agnostic count leading zero bits (All zero bits are considered leading if the value is zero)"],
  "i32.ctz": [0x68, 1, 1, "sign-agnostic count trailing zero bits (All zero bits are considered trailing if the value is zero)"],
  "i32.popcnt": [0x69, 1, 1, "sign-agnostic count number of one bits"],
  "i32.add": [0x6a, 2, 1, "sign-agnostic addition"],
  "i32.sub": [0x6b, 2, 1, "sign-agnostic subtraction"],
  "i32.mul": [0x6c, 2, 1, "sign-agnostic multiplication (lower 32-bits)"],
  "i32.div_s": [0x6d, 2, 1, "signed division (result is truncated toward zero)"],
  "i32.div_u": [0x6e, 2, 1, "unsigned division (result is floored)"],
  "i32.rem_s": [0x6f, 2, 1, "signed remainder (result has the sign of the dividend)"],
  "i32.rem_u": [0x70, 2, 1, "unsigned remainder"],

  "i32.and": [0x71, 2, 1, "sign-agnostic bitwise and"],
  "i32.or": [0x72, 2, 1, "sign-agnostic bitwise inclusive or"],
  "i32.xor": [0x73, 2, 1, "sign-agnostic bitwise exclusive or"],
  "i32.shl": [0x74, 2, 1, "sign-agnostic shift left"],
  "i32.shr_s": [0x75, 2, 1, "sign-replicating (arithmetic) shift right"],
  "i32.shr_u": [0x76, 2, 1, "zero-replicating (logical) shift right"],
  "i32.rotl": [0x77, 2, 1, "sign-agnostic rotate left"],
  "i32.rotr": [0x78, 2, 1, "sign-agnostic rotate right"],

  "i64.clz": [0x79, 1, 1, "sign-agnostic count leading zero bits (All zero bits are considered leading if the value is zero)"],
  "i64.ctz": [0x7a, 1, 1,"sign-agnostic count trailing zero bits (All zero bits are considered trailing if the value is zero)"],
  "i64.popcnt": [0x7b, 1, 1, "sign-agnostic count number of one bits"],
  "i64.add": [0x7c, 2, 1, "sign-agnostic addition"],
  "i64.sub": [0x7d, 2, 1, "sign-agnostic subtraction"],
  "i64.mul": [0x7e, 2, 1, "sign-agnostic multiplication (lower 32-bits)"],
  "i64.div_s": [0x7f, 2, 1, "signed division (result is truncated toward zero)"],
  "i64.div_u": [0x80, 2, 1, "unsigned division (result is floored)"],
  "i64.rem_s": [0x81, 2, 1, "signed remainder (result has the sign of the dividend)"],
  "i64.rem_u": [0x82, 2, 1, "unsigned remainder"],

  "i64.and": [0x83, 2, 1, "sign-agnostic bitwise and"],
  "i64.or": [0x84, 2, 1, "sign-agnostic bitwise inclusive or"],
  "i64.xor": [0x85, 2, 1, "sign-agnostic bitwise exclusive or"],
  "i64.shl": [0x86, 2, 1, "sign-agnostic shift left"],
  "i64.shr_s": [0x87, 2, 1, "sign-replicating (arithmetic) shift right"],
  "i64.shr_u": [0x88, 2, 1, "zero-replicating (logical) shift right"],
  "i64.rotl": [0x89, 2, 1, "sign-agnostic rotate left"],
  "i64.rotr": [0x8a, 2, 1, "sign-agnostic rotate right"],

  "f32.abs": [0x8b, 1, 1, "absolute value"],
  "f32.neg": [0x8c, 1, 1, "negation"],
  "f32.ceil": [0x8d, 1, 1, "ceiling operator"],
  "f32.floor": [0x8e, 1, 1, "floor operator"],
  "f32.trunc": [0x8f, 1, 1, "round to nearest integer towards zero"],
  "f32.nearest": [0x90, 1, 1, "round to nearest integer, ties to even"],
  "f32.sqrt": [0x91, 1, 1, "square root"],
  "f32.add": [0x92, 2, 1, "addition"],
  "f32.sub": [0x93, 2, 1, "subtraction"],
  "f32.mul": [0x94, 2, 1, "multiplication"],
  "f32.div": [0x95, 2, 1, "division"],
  "f32.min": [0x96, 2, 1, "minimum (binary operator); if either operand is NaN, returns NaN"],
  "f32.max": [0x97, 2, 1, "maximum (binary operator); if either operand is NaN, returns NaN"],
  "f32.copysign": [0x98, 2, 1, "copysign"],

  "f64.abs": [0x99, 1, 1, "absolute value"],
  "f64.neg": [0x9a, 1, 1, "negation"],
  "f64.ceil": [0x9b, 1, 1, "ceiling operator"],
  "f64.floor": [0x9c, 1, 1, "floor operator"],
  "f64.trunc": [0x9d, 1, 1, "round to nearest integer towards zero"],
  "f64.nearest": [0x9e, 1, 1, "round to nearest integer, ties to even"],
  "f64.sqrt": [0x9f, 1, 1, "square root"],
  "f64.add": [0xa0, 2, 1, "addition"],
  "f64.sub": [0xa1, 2, 1, "subtraction"],
  "f64.mul": [0xa2, 2, 1, "multiplication"],
  "f64.div": [0xa3, 2, 1, "division"],
  "f64.min": [0xa4, 2, 1, "minimum (binary operator); if either operand is NaN, returns NaN"],
  "f64.max": [0xa5, 2, 1, "maximum (binary operator); if either operand is NaN, returns NaN"],
  "f64.copysign": [0xa6, 2, 1, "copysign"],

  "i32.wrap_i64": [0xa7, 1, 1, "wrap a 64-bit integer to a 32-bit integer"],
  "i32.trunc_f32_s": [0xa8, 1, 1, "truncate a 32-bit float to a signed 32-bit integer"],
  "i32.trunc_f32_u": [0xa9, 1, 1, "truncate a 32-bit float to an unsigned 32-bit integer"],
  "i32.trunc_f64_s": [0xaa, 1, 1, "truncate a 64-bit float to a signed 32-bit integer"],
  "i32.trunc_f64_u": [0xab, 1, 1, "truncate a 64-bit float to an unsigned 32-bit integer"],
  "i64.extend_i32_s": [0xac, 1, 1, "extend a signed 32-bit integer to a 64-bit integer"],
  "i64.extend_i32_u": [0xad, 1, 1, "extend an unsigned 32-bit integer to a 64-bit integer"],
  "i64.trunc_f32_s": [0xae, 1, 1, "truncate a 32-bit float to a signed 64-bit integer"],
  "i64.trunc_f32_u": [0xaf, 1, 1, "truncate a 32-bit float to an unsigned 64-bit integer"],
  "i64.trunc_f64_s": [0xb0, 1, 1, "truncate a 64-bit float to a signed 64-bit integer"],
  "i64.trunc_f64_u": [0xb1, 1, 1, "truncate a 64-bit float to an unsigned 64-bit integer"],
  "f32.convert_i32_s": [0xb2, 1, 1, "convert a signed 32-bit integer to a 32-bit float"],
  "f32.convert_i32_u": [0xb3, 1, 1, "convert an unsigned 32-bit integer to a 32-bit float"],
  "f32.convert_i64_s": [0xb4, 1, 1, "convert a signed 64-bit integer to a 32-bit float"],
  "f32.convert_i64_u": [0xb5, 1, 1, "convert an unsigned 64-bit integer to a 32-bit float"],
  "f32.demote_f64": [0xb6, 1, 1, "demote a 64-bit float to a 32-bit float"],
  "f64.convert_i32_s": [0xb7, 1, 1, "convert a signed 32-bit integer to a 64-bit float"],
  "f64.convert_i32_u": [0xb8, 1, 1, "convert an unsigned 32-bit integer to a 64-bit float"],
  "f64.convert_i64_s": [0xb9, 1, 1, "convert a signed 64-bit integer to a 64-bit float"],
  "f64.convert_i64_u": [0xba, 1, 1, "convert an unsigned 64-bit integer to a 64-bit float"],
  "f64.promote_f32": [0xbb, 1, 1, "promote a 32-bit float to a 64-bit float"],
  "i32.reinterpret_f32": [0xbc, 1, 1, "reinterpret the bits of a 32-bit float as a 32-bit integer"],
  "i64.reinterpret_f64": [0xbd, 1, 1, "reinterpret the bits of a 64-bit float as a 64-bit integer"],
  "f32.reinterpret_i32": [0xbe, 1, 1, "reinterpret the bits of a 32-bit integer as a 32-bit float"],
  "f64.reinterpret_i64": [0xbf, 1, 1, "reinterpret the bits of a 64-bit integer as a 64-bit float"]
}


_groups = {0x00: 'Control',
           0x1A: 'Parametric',
           0x20: 'Variable',
           0x28: 'Memory',
           0x41: 'Constant',
           0x45: 'Logical_i32',
           0x50: 'Logical_i64',
           0x5b: 'Logical_f32',
           0x61: 'Logical_f64',
           0x67: 'Arithmetic_i32',
           0x71: 'Bitwise_i32',
           0x79: 'Arithmetic_i64',
           0x83: 'Bitwise_i64',
           0x8b: 'Arithmetic_f32',
           0x99: 'Arithmetic_f64',
           0xa7: 'Conversion',
           0xc0: 'Unsupported'}
